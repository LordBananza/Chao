/*
 * main.c
 *
 *  Created on: May 11, 2025
 *      Author: lordbananza
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lexer.h"
#include "parser.h"


Token* frontToken;

Instruction* frontInstruction;





/**
 * The Chao compiler works much like a conventional compiler. It uses a lexer to separate the users' input into recognizable tokens
 * which are then given meaning by a parser. The parser then generates an output file of standard VMS assembly code.
 * If you are looking to write your own Chao code, check README.md on the Chao Github page:
 */
int main (int argc , char* argv[]) {
	if (argc != 2) {
		printf("ERROR: please specify only the file to be compiled\n");
		exit(-1);
	}

	FILE *code = fopen(argv[1], "r");

	frontToken = getAllTokens(code);
	
	Token* head = frontToken;

	while (frontToken->next != NULL) {
			printf("%s type: %d\n", frontToken->lexeme, frontToken->type);
			frontToken = frontToken->next;
	}
	
	printf("\n\n");

	
	
	frontInstruction = parseTokens(head);
	
	FILE *output = fopen(strcat(argv[1], ".s"), "w");
	fprintf(output, "\t;; Assembly code generated by Chao Compiler.\n\t;; Use aslc86k to assemble this.\n\n\t.include \"sfr.i\"\n\n");
	
	//Interrupt Vectors
	//TODO finish these interrupts' instructions
	fprintf(output, "\t.org $00\n\t;; Reset Signal\n\n");
	
	fprintf(output, "\t.org $03\n\t;; INT0 interrupt\n\n");
	
	fprintf(output, "\t.org $0b\n\t;; INT1 interrupt\n\n");
	
	fprintf(output, "\t.org $13\n\t;; INT2 interrupt or T0L (timer) overflow\n\n");
	
	fprintf(output, "\t.org $1b\n\t;; INT3 interrupt or Base Timer overflow\n\n");
	
	fprintf(output, "\t.org $23\n\t;; T0H (timer) overflow\n\n");
	
	fprintf(output, "\t.org $2b\n\t;; T1H or T1L overflow\n\tnot1 ext, 0\n\tjmpf $130\n\n");
	
	//TODO finish these interrupts' descriptions and instructions
	fprintf(output, "\t.org $33\n\n");
	
	fprintf(output, "\t.org $3b\n\n");
	
	fprintf(output, "\t.org $43\n\n");
	
	fprintf(output, "\t.org $4b\n\n");
	
	
	
	//Necessary file headers 
	fprintf(output, "\t.org $200\n\t;; Short File Description (Put your own 16-character description below)\n\t.byte \"Game by Chao    \"\n\n");
	
	fprintf(output, "\t.org $210\n\t;; Long File Description (Put your own 32-character description below)\n\t.byte \"Code Generated by Chao Language \"\n\n");
	
	fprintf(output, "\t.org $240\n\t;; Number of icons to appear in Dreamcast BIOS, followed by icon animation speed\n\t.word 1,0\n\n");
	
	fprintf(output, "\t.org $260\n\t;; Color pallette for icon in Dreamcast BIOS\n\t.word $ffff,$f000,$0000,$0000,$0000,$0000,$0000,$0000\n\t.word $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000\n\n");
	
	fprintf(output, "\t.org $280\n\t;; Icon (represented as a bitmap referencing the above color pallete)\n");
	
	//Icon printing
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$11,$11,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$11,$11,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$11,$11,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$01,$10,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$11,$11,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$01,$11,$11,$11,$11,$10,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$11,$11,$11,$11,$11,$11,$11,$11,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$01,$11,$11,$11,$11,$11,$11,$11,$11,$10,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$01,$11,$11,$00,$00,$11,$11,$00,$00,$11,$11,$10,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$11,$11,$11,$00,$00,$11,$11,$00,$00,$11,$11,$11,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$11,$11,$11,$00,$00,$11,$11,$00,$00,$11,$11,$11,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$01,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$10,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$11,$11,$11,$11,$11,$11,$11,$11,$11,$11,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$01,$11,$11,$11,$11,$11,$11,$11,$11,$10,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$11,$11,$11,$11,$11,$11,$11,$11,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$01,$11,$11,$11,$11,$11,$11,$10,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$11,$11,$11,$11,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$11,$11,$01,$10,$01,$10,$00,$01,$10,$00,$00,$11,$00,$00\n");
	fprintf(output, "\t.byte $00,$11,$00,$00,$01,$10,$01,$10,$00,$10,$01,$00,$01,$00,$10,$00\n");
	fprintf(output, "\t.byte $00,$11,$00,$00,$01,$11,$11,$10,$01,$00,$00,$10,$10,$00,$01,$00\n");
	fprintf(output, "\t.byte $00,$11,$00,$00,$01,$11,$11,$10,$01,$11,$11,$10,$10,$00,$01,$00\n");
	fprintf(output, "\t.byte $00,$11,$00,$00,$01,$11,$11,$10,$11,$11,$11,$11,$10,$00,$01,$00\n");
	fprintf(output, "\t.byte $00,$11,$00,$00,$01,$10,$01,$10,$10,$00,$00,$01,$01,$00,$10,$00\n");
	fprintf(output, "\t.byte $00,$00,$11,$11,$01,$10,$01,$10,$10,$00,$00,$01,$00,$11,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	fprintf(output, "\t.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00\n");
	
	fprintf(output, "\t;Start of code\n\t.org\t$480\n\n");
	
	int count = 1;
	while (frontInstruction->next->next != NULL) {
			printf("Instruction #%d: %s %s %s %s %s\n", count++, frontInstruction->header, frontInstruction->type, frontInstruction->op1, frontInstruction->op2, frontInstruction->op3);
			
			if (frontInstruction->header == NULL) {for (int i = 0; i < frontInstruction->tabCount; ++i) {fprintf(output, "\t");}}
			
			if (frontInstruction->header != NULL) {
				fprintf(output, "%s ", frontInstruction->header);
			}
			
			if (frontInstruction->type != NULL) {
				fprintf(output, "%s", frontInstruction->type);
			}
			
			if (frontInstruction->op1 != NULL) {
				fprintf(output, " %s", frontInstruction->op1);
			}
			if (frontInstruction->op2 != NULL) {
				fprintf(output, " %s", frontInstruction->op2);
			}
			if (frontInstruction->op3 != NULL) {
				fprintf(output, " %s", frontInstruction->op3);
			}
			fprintf(output, "\n");
			
			frontInstruction = frontInstruction->next;
	}

	fclose(code);

}
