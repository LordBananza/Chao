/*
 * main.c
 *
 *  Created on: May 11, 2025
 *      Author: lordbananza
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lexer.h"
#include "parser.h"


Token* frontToken;

Instruction* frontInstruction;





/**
 * The Chao compiler works much like a conventional compiler. It uses a lexer to separate the users' input into recognizable tokens
 * which are then given meaning by a parser. The parser then generates an output file of standard VMS assembly code.
 * If you are looking to write your own Chao code, check README.md on the Chao Github page:
 */
int main (int argc , char* argv[]) {
	if (argc != 2) {
		printf("ERROR: please specify only the file to be compiled\n");
		exit(-1);
	}

	FILE *code = fopen(argv[1], "r");

	frontToken = getAllTokens(code);
	
	Token* head = frontToken;

	while (frontToken->next != NULL) {
			printf("%s type: %d\n", frontToken->lexeme, frontToken->type);
			frontToken = frontToken->next;
	}
	
	printf("\n\n");

	
	
	frontInstruction = parseTokens(head);
	
	FILE *output = fopen(strcat(argv[1], ".s"), "w");
	fprintf(output, "\t;; Assembly code generated by Chao Compiler.\n\t;; Use aslc86k to assemble this.\n\n\t.include \"sfr.i\"\n\n");
	
	int count = 1;
	while (frontInstruction->next->next != NULL) {
			printf("Instruction #%d: %s %s %s %s %s\n", count++, frontInstruction->header, frontInstruction->type, frontInstruction->op1, frontInstruction->op2, frontInstruction->op3);
			
			for (int i = 0; i < frontInstruction->tabCount; ++i) {fprintf(output, "\t");}
			
			if (frontInstruction->header != NULL) {
				fprintf(output, "%s ", frontInstruction->header);
			}
			
			if (frontInstruction->type != NULL) {
				fprintf(output, "%s", frontInstruction->type);
			}
			
			if (frontInstruction->op1 != NULL) {
				fprintf(output, " %s", frontInstruction->op1);
			}
			if (frontInstruction->op2 != NULL) {
				fprintf(output, " %s", frontInstruction->op2);
			}
			if (frontInstruction->op3 != NULL) {
				fprintf(output, " %s", frontInstruction->op3);
			}
			fprintf(output, "\n");
			
			frontInstruction = frontInstruction->next;
	}

	fclose(code);

}
